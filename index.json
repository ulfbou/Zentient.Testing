{
  "CHANGELOG.html": {
    "href": "CHANGELOG.html",
    "title": "CHANGELOG — Zentient.Testing | Zentient.Abstractions API Reference",
    "keywords": "CHANGELOG — Zentient.Testing All notable changes to this project are recorded in this file. This project follows Semantic Versioning. Unreleased Working toward 0.1.0 (alpha) — internal validation, tests and packaging. [0.1.0-alpha.1] - 2025-09-18 Initial public alpha release of Zentient.Testing. This lightweight package provides a small, ergonomic testing DSL and harness for Arrange → Act → Assert flows without depending on a platform DI container. Highlights Added public abstractions in Zentient.Abstractions.Testing: ITestScenario, ITestHarnessBuilder, IMockBuilder, IResultAssertions. Implemented a minimal TestHarness and TestHarnessBuilder that support WithDependency, WithMock and Replace semantics. Small built-in mock engine with Given(...).ThenReturns(...) and ThenThrows(...), plus a simple verifier API. Result assertions: NotBeNull, HaveValue, With(selector, expected) and chaining. Expression utilities (Zentient.Expressions) exposed via ExpressionRegistry.DefaultParser and DefaultEvaluator and validated by unit tests. CI and packaging: projects multi-target net8.0/net9.0, packable metadata added and a validated pack pipeline (local validation). Validation scripts: scripts to load .env and validate build/test/pack locally. Notes This alpha is intentionally small and non-invasive: it avoids exposing concrete DI or mocking frameworks in public API. Adapters (Moq, Microsoft DI) and broader diagnostics are planned for beta. Tests currently run using xUnit + FluentAssertions in the test project; a VSTest adapter for running tests that only reference Zentient.Testing is a future task (beta/RC)."
  },
  "CODE_OF_CONDUCT.html": {
    "href": "CODE_OF_CONDUCT.html",
    "title": "Code of Conduct | Zentient.Abstractions API Reference",
    "keywords": "Code of Conduct Our Commitment We are committed to providing a welcoming, inclusive, and harassment-free community for everyone. We value respectful interactions, helpful feedback, and constructive collaboration. Expected Behavior Be professional, courteous, and empathetic in all communications. Be open to feedback and act respectfully when discussing disagreements. Use inclusive language and avoid discriminatory remarks. Unacceptable Behavior Harassment, threats, or hateful conduct of any kind. Personal attacks, doxxing, or public shaming. Unwanted sexual attention or harassment. Reporting and Enforcement If you experience or witness unacceptable behavior, please report it to the project maintainers at **zentientdev@gmail.com**. Maintainers will investigate reports promptly and take appropriate action. Possible enforcement actions include: Private warning and request for corrective behavior. Temporary restriction of contribution privileges. Permanent banning from project spaces for severe or repeated violations. We commit to handling reports confidentially and fairly. Attribution: This code of conduct is adapted from standard open-source community templates and follows best practices for community moderation."
  },
  "README.html": {
    "href": "README.html",
    "title": "Zentient.Testing | Zentient.Abstractions API Reference",
    "keywords": "Zentient.Testing Lightweight test harness, minimal mock engine, and scenario DSL (Arrange → Act → Assert). Zentient.Testing provides a compact, dependency-light testing framework intended for fast, readable tests of handler-style components. The alpha release focuses on ergonomics and a small, stable public surface; advanced DI and mocking adapters are planned for future releases. Highlights (Alpha) Small public surface in Zentient.Abstractions.Testing: ITestScenario, ITestHarnessBuilder, IMockBuilder, IResultAssertions. Lightweight implementation in Zentient.Testing: TestHarness, MockBuilder, ResultAssertions and a tiny mock engine. Multi-targeted to .NET 8 and .NET 9. Quickstart Install the alpha package from your feed (or local artifacts): dotnet add package Zentient.Testing --version 0.1.0-alpha.1 Minimal example // Arrange: create scenario that constructs/resolves a handler from the harness var scenario = TestScenario.ForHandler<MyHandler, MyInput, MyResult>((h, input, ct) => Task.FromResult(h.Handle(input))); scenario.Arrange(builder => { builder.WithDependency<IMyRepository>(new InMemoryRepository()); builder.WithMock<IMyService>(m => m.Given(x => x.Calculate(It.IsAny<int>())).ThenReturns(42)); }); // Act var result = await scenario.ActAsync(new MyInput()); // Assert scenario.Assert(a => a.NotBeNull()); scenario.Assert(a => a.With(r => r.Value, 42)); Documentation See the docs/ folder for detailed information: Architecture and design principles API reference and usage examples Packaging and release notes Running tests & local validation Tests in this repository use xUnit for discovery. Run them with: dotnet test For local CI-style validation (build → test → pack) use the included script: ..\\ulfbou\\scripts\\validate.ps1 Contributing Contributions are welcome. Please respect the Code of Conduct and follow contribution guidelines in the repository. License MIT — see the LICENSE file for details."
  },
  "docs/TESTING_README.html": {
    "href": "docs/TESTING_README.html",
    "title": "Zentient.Testing — Alpha Quickstart | Zentient.Abstractions API Reference",
    "keywords": "Zentient.Testing — Alpha Quickstart This document shows how to use the lightweight Zentient.Testing harness and mock APIs in the alpha release. Arrange → Act → Assert Example: var scenario = TestScenario.ForHandler<MyHandler, (int a, int b), int>((h, input, ct) => Task.FromResult(h.Handle(input))); scenario.Arrange(builder => { builder.WithMock<ICalculator>(mb => mb.Given(x => x.Add(It.IsAny<int>(), It.IsAny<int>())).ThenReturns(42)); }); int result = await scenario.ActAsync((1, 2)); scenario.Assert(a => a.HaveValue(42)); FluentAssertions license note This repository includes tests that use FluentAssertions. FluentAssertions is published under the Xceed Fluent Assertions Community License. The project is free for non-commercial use. If you plan to use these tests in a commercial product or CI environment for a proprietary code base, please review the FluentAssertions licensing terms and obtain a commercial license if required: https://xceed.com/products/unit-testing/fluent-assertions/ Nullability The alpha APIs aim to provide nullable-aware signatures for common operations. ThenReturns(object? result) accepts null when configuring void-returning methods in the minimal mock DSL. Recommended test additions for alpha Add tests for behaviour priority and multiple matching rules. Test exception throwing from ThenThrows. Test async handlers and Task-returning methods. These are already partly implemented in the example tests included in tests/."
  },
  "docs/alfa-release-notes.html": {
    "href": "docs/alfa-release-notes.html",
    "title": "Alpha Release Notes � Zentient.Testing (0.1.0-alpha) | Zentient.Abstractions API Reference",
    "keywords": "Alpha Release Notes � Zentient.Testing (0.1.0-alpha) This document summarizes the scope and limitations of the alpha release. Scope Minimal public abstractions (ITestScenario, ITestHarnessBuilder, IResultAssertions, IMockBuilder). Lightweight TestHarness implementation with per-test registrations and simple constructor resolution. Built-in mock engine providing Given(...).ThenReturns(...) and ThenThrows(...), basic verifier semantics. Result assertion helpers for common checks. Limitations No platform DI integration; adapters planned for beta. No VSTest test adapter � tests are executed using existing test frameworks (xUnit) in CI. Diagnostics and analyzers are not yet implemented. Migration notes Alpha API is intentionally small and may evolve into beta. Keep tests and usage patterns minimal and prefer the public abstractions."
  },
  "docs/api-reference.html": {
    "href": "docs/api-reference.html",
    "title": "API Reference � Zentient.Testing (Alpha) | Zentient.Abstractions API Reference",
    "keywords": "API Reference � Zentient.Testing (Alpha) This reference lists the main public interfaces and their primary members. For in-depth XML docs consult compiled nuget package or inline XML in source. ITestScenario<TInput,TResult> ITestHarnessBuilder IMockBuilder IResultAssertions (Alpha: reference intentionally minimal; will be expanded for beta/RC.)"
  },
  "docs/api.html": {
    "href": "docs/api.html",
    "title": "API Reference � Zentient.Testing (Alpha) | Zentient.Abstractions API Reference",
    "keywords": "API Reference � Zentient.Testing (Alpha) This document merges the API overview and reference for the alpha release. It describes the public abstractions provided by Zentient.Abstractions.Testing, their responsibilities, and short usage examples. Overview The alpha API is deliberately small. Target interfaces: ITestScenario<TInput, TResult> � orchestrates Arrange ? Act ? Assert for a handler or SUT. ITestHarnessBuilder � builder API used during Arrange to register dependencies and mocks. IMockBuilder � minimal mock DSL for configuring behaviors. IResultAssertions � assertion helpers used by scenario.Assert. Interfaces ITestScenario<TInput, TResult> Purpose: Encapsulate a unit test scenario for a handler or SUT and provide the fluent test lifecycle. Members: Arrange(Action configure) Task ActAsync(TInput input, CancellationToken ct = default) Assert(Action<IResultAssertions > assertions) Example: var scenario = TestScenario.ForHandler<MyHandler, MyInput, MyResult>((h,input,ct) => Task.FromResult(h.Handle(input))); scenario.Arrange(builder => builder.WithDependency(...)); var result = await scenario.ActAsync(...); scenario.Assert(a => a.NotBeNull()); ITestHarnessBuilder Purpose: Provide test-scoped registration APIs for dependencies and mocks. Common methods: WithDependency (TService instance) WithMock (Action<IMockBuilder > configure) Replace (TService instance) Build() Notes: For the alpha, Build returns an internal TestHarness that resolves types either from registrations or by construction when possible. IMockBuilder Purpose: Configure simple stubs for a service type. API surface (alpha): Given(Expression<Func<TService, object>> call) ThenReturns(object result) ThenThrows(Exception ex) Example: builder.WithMock<ICalc>(m => m.Given(x => x.Add(It.IsAny<int>(), It.IsAny<int>())).ThenReturns(42)); IResultAssertions Purpose: Provide a focused set of assertion helpers used inside scenario.Assert. Helpers (alpha): NotBeNull() HaveValue(TResult expected) With (Expression<Func<TResult, TProperty>> selector, TProperty expected) And (chaining) Example: scenario.Assert(a => a.With(r => r.Value, 42).And.NotBeNull()); Guidance & Migration Notes Code against the abstractions, not concrete implementations, to simplify future adapter work. Expect small API additions in beta; core shapes should remain stable for adapter integration. Where to find more See docs/usage-examples.md for copy-pasteable examples. For packaging and CI, refer to docs/packaging.md and the GitHub Actions workflow."
  },
  "docs/architecture.html": {
    "href": "docs/architecture.html",
    "title": "Architecture � Zentient.Testing (Alpha) | Zentient.Abstractions API Reference",
    "keywords": "Architecture � Zentient.Testing (Alpha) This document provides a concise, high-level architecture overview for the alpha release of Zentient.Testing. It is intended for contributors and maintainers who implement or integrate the library. Goals Provide a compact, test-first DSL for Arrange ? Act ? Assert flows. Avoid leaking concrete DI or mocking framework types in the public API for alpha. Keep the implementation small, well-delineated, and easy to reason about. High-level Components Zentient.Abstractions.Testing (public) Interfaces and small DTOs consumed by tests: ITestScenario, ITestHarnessBuilder, IMockBuilder, IResultAssertions. Zentient.Testing (implementation) Test harness (TestHarness, TestHarnessBuilder): per-test service registry and simple resolver. Mock engine (MockBuilder, MockEngine): expression-driven stubs with ThenReturns/ThenThrows semantics. Assertions (ResultAssertions): helper methods for concise assertions and chaining. Tests Unit tests and integration smoke tests exercising the harness, mock engine and expression evaluator. Component Responsibilities TestHarnessBuilder Collect registrations (WithDependency, WithMock, Replace). Materialize a TestHarness via Build(). TestHarness Provide Resolve () with the following priority: Return registered instance if present. Attempt to construct via public constructor when all parameter types are registered. Throw a descriptive invalid operation exception when resolution fails. Dispose any IDisposable registrations when disposed. MockBuilder / MockEngine Allow mapping a captured call expression to a behavior (return value or exception). Provide a verifier that can assert invocation counts (basic semantics in alpha). ResultAssertions Expose small set of assertion helpers: NotBeNull, HaveValue, With(selector, expected), and chaining via And. Data flow (ASCII) Test code -> TestScenario -> TestHarnessBuilder -> TestHarness -> Resolve SUT -> MockBuilder -> Mock instances injected into harness Future evolution (beta/RC) Adapter layering for DI (Microsoft DI) and mocking frameworks (Moq) to avoid reimplementation and provide richer mocking features. Diagnostics and validation hooks during Build() to surface registration issues earlier. Roslyn analyzers and performance tuning in later stages. Non-goals for alpha A full DI container implementation. Advanced mock verification features (spies, complex matchers beyond It.IsAny in alpha). Notes The architecture favors clarity over completeness. Keep public contracts minimal and stable for the alpha."
  },
  "docs/design-principles.html": {
    "href": "docs/design-principles.html",
    "title": "Design Principles � Zentient.Testing | Zentient.Abstractions API Reference",
    "keywords": "Design Principles � Zentient.Testing Developer Experience first: prioritize terse, discoverable APIs. Non-invasive: do not expose concrete DI/mocking framework types in public interfaces. Test-scoped isolation: each harness instance represents a test scope and disposes local resources. Fail-fast diagnostics: descriptive, actionable exceptions for misconfiguration. Progressive enhancement: small alpha core, then adapters and diagnostics in beta."
  },
  "docs/getting-started.html": {
    "href": "docs/getting-started.html",
    "title": "Getting Started — Zentient.Testing (Alpha) | Zentient.Abstractions API Reference",
    "keywords": "Getting Started — Zentient.Testing (Alpha) This quick guide helps you add Zentient.Testing to a project, write a simple scenario-based test, and run local validation for build/test/pack. Prerequisites .NET 8 SDK or later (the project also targets .NET 9). Optional: a unit test runner (xUnit is used in this repository for discovery). Install Add the package from your NuGet feed (replace version as needed): dotnet add package Zentient.Testing --version 0.1.0-alpha Or add the project reference if working from source: dotnet add <your-test-project> reference <path-to>/src/Zentient.Testing/Zentient.Testing.csproj Write a simple test Example using a handler-style SUT: [Fact] public async Task AdderHandler_ReturnsConfiguredMockValue() { var scenario = TestScenario.ForHandler<AdderHandler,(int a,int b),int>((h,input,ct) => Task.FromResult(h.Handle(input))); scenario.Arrange(builder => { builder.WithMock<ICalculator>(mb => mb.Given(x => x.Add(It.IsAny<int>(), It.IsAny<int>())).ThenReturns(100)); }); var result = await scenario.ActAsync((1,2)); scenario.Assert(a => a.With(r => r, 100)); } Run tests Run tests using your preferred test runner. Example with dotnet test: dotnet test Note: This repository uses xUnit for test discovery. The final product may ship adapters that remove the direct need for xUnit in the test project in a later release. Local CI-style validation (build → test → pack) A convenience script is provided to validate the repository locally, performing build, test and pack steps. ..\\ulfbou\\scripts\\validate.ps1 The script will: Load environment variables from ../.env if present. Build all src/ projects. Build and run tests in tests/. Pack any project with <IsPackable>true</IsPackable> into artifacts/. Attempt to sign packages if SIGNING_KEY is present in the environment. Troubleshooting If dotnet test cannot discover tests, ensure the test project references an appropriate test SDK (e.g., Microsoft.NET.Test.Sdk & xUnit runner) or use the provided validate.ps1 which builds projects before invoking tests. If packaging fails due to missing README.md, ensure README.md exists at the repository root; packaging expects this file to be included in nupkg. Next steps Read the API Reference: docs/api.md. Explore example scenarios: docs/usage-examples.md. Review packaging guidance: docs/packaging.md."
  },
  "docs/internal/README.html": {
    "href": "docs/internal/README.html",
    "title": "| Zentient.Abstractions API Reference",
    "keywords": "Zentient.Testing � Internal Documentation This directory contains the internal wiki pages and documentation intended for maintainers, contributors and early adopters of the alfa release of Zentient.Testing. Files api-reference-alfa.md � full API reference for the alfa release (surface area & examples) roadmap.md � short- and medium-term roadmap and release plan release-notes-alfa.md � alfa release notes and migration guidance contributing.md � contributor guidance, development workflow and commit conventions Internal wiki (maintainer-facing) wiki/index.md � Overview & introduction wiki/getting-started.md � Quick start and running tests locally wiki/concepts.md � Core concepts and mental model wiki/architecture.md � High level architecture and extension points wiki/usage-examples.md � Recipes and example patterns How to use These pages are written for Markdown-driven hosting (GitHub Pages / Docs). Keep them up to date when you change public APIs. API reference is intentionally compact for the alfa; expand signatures and examples as APIs stabilize. Contact For questions about the design or release process open an issue or ping the maintainers in the repository. Notes These files are internal and should not be published publicly without review. They remain local to maintainers and are intentionally kept out of public releases."
  },
  "docs/internal/Specification.html": {
    "href": "docs/internal/Specification.html",
    "title": "Zentient.Testing — Staged Implementation Specification (Alpha → Beta → RC → 1.0) | Zentient.Abstractions API Reference",
    "keywords": "Zentient.Testing — Staged Implementation Specification (Alpha → Beta → RC → 1.0) Below is a complete, implementer-focused specification for each staged release of Zentient.Testing. It enables engineers to implement the library end-to-end without waiting for additional design decisions. This document provides precise class/interface names, method signatures (described), constructor responsibilities, invariants, implementation steps, tests to write, CI/packaging steps, and acceptance criteria for each stage. Overview / Guiding Principles (All Stages) DX-first: APIs should be terse, discoverable, and read like Arrange → Act → Assert. Defaults must be sensible; advanced options are opt-in. Non-invasive: Public API should not expose concrete DI/mocking framework types. Use adapter patterns and abstractions. Test-scoped isolation: Each test gets its own harness instance; resources registered by a harness are disposed when the harness is disposed. Fail-fast diagnostics: Developer-facing exceptions should be descriptive and actionable. Progressive enhancement: Start small (alpha), then add DI and adapters (beta), then analyzers and advanced diagnostics (RC), then polish and ecosystem adapters (1.0). Common Naming & Packaging Conventions (All Stages) Root NuGet: Zentient.Testing (alpha; gradually add modular packages). Recommended Subpackages: Zentient.Testing.Abstractions — all public interfaces and minimal DTOs (always) Zentient.Testing.Internal — default implementations (alpha/beta) Zentient.Testing.Adapters.Moq — Moq adapter (beta) Zentient.Testing.Hosting.MicrosoftDi — Microsoft DI adapter (beta) Zentient.Testing.Diagnostics — extended diagnostics (RC) Zentient.Testing.Analyzers — Roslyn analyzer pack (RC/1.0) Namespaces mirror packages. Interfaces begin with I. Keep classes small and single-responsibility. ALPHA (0.1.x) — Core DSL and Harness WITHOUT Platform DI Goal: Validate the Arrange → Act → Assert flow, runtime ergonomics, and the mocking DSL without depending on Zentient.DependencyInjection. Implementer Surface Public contracts (in Zentient.Testing.Abstractions): ITestScenario<TInput, TResult> Arrange(Action<ITestHarnessBuilder> configure) — zero or more configure actions (idempotent: multiple calls append) ActAsync(TInput input, CancellationToken ct = default) — invokes SUT using harness resolution rules; returns Task<TResult> Assert(Action<IResultAssertions<TResult>> assertions) — runs sync assertions on the TResult ITestHarnessBuilder WithDependency<TService>(TService instance) — register concrete instance local to harness WithMock<TService>(Action<IMockBuilder<TService>> configure) — configure a mock with the built-in mock engine (alpha: minimal stub) Replace<TService>(TService instance) — explicit replace semantics Build() — returns ITestHarness (private/impl type or small resolver; for alpha, a lightweight resolver local to harness) IMockBuilder<TService> — DSL: Given(Expression<Func<TService, object>> call) — identify method/property call to stub ThenReturns(object result) — return specified value ThenThrows(Exception ex) — throw when called IResultAssertions<TResult> NotBeNull() HaveValue(TResult expected) With<TProperty>(Expression<Func<TResult, TProperty>> selector, TProperty expected) And chaining Internal type ITestHarness (impl-only): Small, per-test service registry that maps service type → instance (singleton-in-test). Not a full DI container. Default Behaviors / Conventions SUT resolution: Prefer harness-registered instance. Otherwise, construct via reflection if constructor parameters are all registered. Otherwise, throw descriptive exception. Mocks: Tiny, internal mock engine: maps expressions to behaviors, returns configured values or throws. Provide simple Verify method on mock builder (not enforced). Contexts: Contextual data via WithDependency<TContext>(contextInstance) (no typed IContext in alpha). Implementation Tasks (Alpha) Create abstractions project. Add interfaces above, with XML docs. Implement harness (Impl project). Implement TestScenario<THandler, TInput, TResult> factory. Implement TestHarnessBuilder with internal dictionary Type → object. Build() returns TestHarness (internal), which provides Resolve<T>() : T. Implement small mock engine. Minimal expression parser, store behaviors in a dictionary. Assertions implementation. Implement ResultAssertions<TResult> using test-runner-friendly approach. Example tests and docs. Show Arrange/Act/Assert flows with dependencies and mocks. Unit tests for the library itself. Test harness build/dispose, SUT resolution, mock DSL, assertions. CI / Packaging (Alpha) Single library package Zentient.Testing (Abstractions + Impl). CI steps: run unit tests, build NuGet package (0.1.0-alpha.*), push to feed. Acceptance Criteria (Alpha) ITestScenario flows compile/run without external DI dependencies. Mocks can be configured to return/throw. SUT resolution works for simple constructors; failure case includes actionable error. BETA (0.2.x) — Add Zentient.DependencyInjection Integration, Adapters & Basic Diagnostics Goal: Introduce the real DI surface (via adapters), enable DI diagnostics in tests. Precondition: Zentient.DependencyInjection available as an upstream package (preferred) or create an internal shim. Implementer Surface Abstractions (augmented): Keep Zentient.Testing.Abstractions stable from alpha. Add small interfaces/types referencing Zentient DI contracts (do not duplicate types; reference them). ITestHarnessBuilder now gains: ConfigureServices(Action<IServiceRegistrationBuilder> configure) WithContext<TContextDefinition>(IContext<TContextDefinition> context) ITestHarnessBuilder.Build() returns IServiceResolver or a thin wrapper. Add IMockAdapter abstraction: CreateMock<TService>() : IMockBuilder<TService> GetInstance<TService>(IMockBuilder<TService> builder) : object Hosting adapters: Implement Zentient.Testing.Hosting.MicrosoftDi: Maps harness builder calls to IServiceRegistrationBuilder. Build() materializes an IServiceResolver that wraps the container. Optionally implement a simple container for minimal DI semantics. Mock adapters: Zentient.Testing.Adapters.Moq: Implements IMockAdapter using Moq. Provide UseMoq() extension method. Diagnostics & validation: Integrate IServiceValidator from Zentient.DependencyInjection. Expose IDiagnosticsAssertions to allow test assertions on DI graph. Harness can run validation automatically during Build() if enabled. Implementation Tasks (Beta) Reference Zentient.DependencyInjection contracts or provide a temporary shim. Extend HarnessBuilder to use IContainerBuilder. Implement Microsoft DI adapter. Implement Moq adapter. Add diagnostics layer (ITestHarnessBuilder.Diagnostics, IDiagnosticsAssertions). Create integration tests (harness + adapters + diagnostics). CI / Packaging (Beta) Split packages: Zentient.Testing, Zentient.Testing.Adapters.Moq, Zentient.Testing.Hosting.MicrosoftDi. CI: unit/integration tests, build sample projects, package artifacts, publish to preview feed. Acceptance Criteria (Beta) ITestScenario builds/uses real DI via adapter. Mocks created by adapter are injected. Diagnostics endpoints provide registration maps and validations. Example repo demonstrates typed context, mock, and DI-hosted SUT. RELEASE CANDIDATE / STABILIZATION (0.9.x) — Analyzers, Strong Diagnostics, Ergonomics Goal: Stabilize API, add Roslyn analyzers, advanced diagnostics, and developer ergonomics. Implementer Surface API finalization: Freeze public API, document compatibility rules. Advanced diagnostics & statistics: IRegistrationStatistics (counts by lifetime/type). IDependencyGraphAnalysis (topological ordering, cycles, depth). Harness Snapshot() and Diff(snapshot) features. Harness options: AutoValidateOnBuild, ValidateOnAct, configurable via static config or builder. Roslyn Analyzers: (in Zentient.Testing.Analyzers) Detect missing await, missing context, mocks after Act, DI lifetime mismatches. Provide code fixes. Performance & resiliency: Resolver performance for many tests, harden disposal semantics. Documentation & examples: Cookbook, migration notes, best practices, sample repo (xUnit & NUnit). Implementation Tasks (RC) Finalize API, XML docs. Implement statistics and snapshot/diff. Build/test analyzers and code-fix providers. Cross-platform CI. Performance benchmarks. CI / Packaging (RC) Pack/sign packages. Staged release channel. Publish analyzers separately. Acceptance Criteria (RC) Public API is frozen. Analyzers detect/fix patterns. Diagnostics reliable; snapshot/diff accurate. Cross-platform CI green. STABLE (1.0.0) — Production-Ready, Full Alignment with Zentient.DependencyInjection Goal: Deliver a robust, mature, and extensible testing ecosystem. Implementer Surface Final features: Full set of adapters: Moq, NSubstitute, FakeItEasy, etc. Hosting adapters: Microsoft DI, Autofac, etc. Decorators/interceptors: WithDecorator<TService, TDecorator>(), WithInterceptor<TService, TInterceptor>(). Advanced metadata assertions. Optional runtime UI/console diagnostics for failing tests. Security & maintenance: Harden dependencies, provide LTS policy, SemVer commitment. Community & extensibility: Contributor guide, extension API docs, template repo. Implementation Tasks (1.0) Implement/publish all hosting and mocking adapters. Add decorator/interceptor APIs. Polish docs/changelogs/guides. Coordinate release of Zentient.DependencyInjection stable. CI / Packaging (1.0) Semantic versioning, release notes. Multi-targeting to .NET LTS. Single-using experience: recommend Zentient.Testing and TestScenario.For<...>(). Acceptance Criteria (1.0) Consumers can write tests for complex DI graphs, decorators, interceptors with minimal ceremony. All analyzers/diagnostics are stable. Clean package graph for enterprise. Per-Stage Testing Matrix Alpha: Harness dictionary semantics, SUT resolution, mock engine, integration flows. Beta: All alpha tests, container-backed harness, diagnostics, contract tests. RC: Analyzer unit tests, snapshot/diff, performance. 1.0: Multi-target integration, interoperability, security/fuzz. Developer Ergonomics & Examples Implement and test these example patterns: Simple unit handler (alpha): WithDependency for repository, WithMock for service, ActAsync, assert result. DI-backed handler with context (beta): Typed context registration, UseMicrosoftDi, assert context/repository in handler. Mock injection via adapter (beta): WithMock using adapter DSL, build harness, resolve SUT, run assert. DI validation use-case (beta/RC): Create circular dependency, call ValidateDi, assert failure. Backwards Compatibility & Migration Strategy Alpha → Beta: Keep alpha APIs. Add new methods as optional, provide compatibility shims. Beta → RC: Freeze API, communicate deprecation, provide codemods. RC → 1.0: Only opt-in enhancements or critical fixes. Documentation and Onboarding Each stage: Publish quickstart, cookbook, adapter guide, diagnostics reference, migration guide. Example projects: xUnit & NUnit, aligned with docs. CI/CD & Release Process Alpha: Unit tests → package → preview feed. Beta: Unit + integration tests, semantic pre-release, preview feed, RC artifacts. RC: Full test matrix, analyzer tests, performance, sign/tag. Release: Coordinate with Zentient.DependencyInjection, publish 1.0.0. Security, Licensing, and Contribution MIT license (or agreed OSS); document CLA if needed. Pin third-party dependencies, scan with SCA tools. Accept adapter contributions, template PR checks. Roadmap Summary 0.1.x (Alpha): Core DSL, harness, tiny mock engine, example repo. 0.2.x (Beta): DI integration, Moq adapter, diagnostics, validation. 0.9.x (RC): Analyzers, snapshots, stats, docs. 1.0.0: Multiple adapters, decorators/interceptors, polished diagnostics, full alignment with Zentient.DependencyInjection stable."
  },
  "docs/internal/Zentient.Expressions.Api.0.1.0-alfa.html": {
    "href": "docs/internal/Zentient.Expressions.Api.0.1.0-alfa.html",
    "title": "| Zentient.Abstractions API Reference",
    "keywords": "===== src/Zentient.Abstractions.Expressions/ExpressionKind.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using System; using System.Collections.Generic; using System.Globalization; namespace Zentient.Abstractions.Expressions { /// /// Specifies the kind of expression. /// public enum ExpressionKind { /// /// An expression representing a constant value. /// Constant, /// <summary> /// An expression representing an identifier. /// </summary> Identifier, /// <summary> /// An expression representing member access. /// </summary> MemberAccess, /// <summary> /// An expression representing a method call. /// </summary> MethodCall, /// <summary> /// An expression representing a lambda expression. /// </summary> Lambda } } ===== src/Zentient.Abstractions.Expressions/IExpression.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // namespace Zentient.Abstractions.Expressions { /// /// Represents an expression in the Zentient abstraction. /// public interface IExpression { /// /// Gets the kind of the expression. /// ExpressionKind Kind { get; } /// <summary> /// Gets the canonical string representation of the expression. /// </summary> string Canonical { get; } /// <summary> /// Gets the operands of the expression. /// </summary> IReadOnlyList<IExpression> Operands { get; } } } ===== src/Zentient.Abstractions.Expressions/IExpressionEvaluator.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // namespace Zentient.Abstractions.Expressions { /// /// Evaluates expressions to obtain their numeric value. /// public interface IExpressionEvaluator { /// /// Evaluates the specified expression in the given context. /// /// The expression to evaluate. /// The context in which to evaluate the expression, or null for no context. /// The numeric value of the expression. object? Evaluate(IExpression expression, object? context = null); } } ===== src/Zentient.Abstractions.Expressions/IExpressionParser.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // namespace Zentient.Abstractions.Expressions { /// /// Parses expressions from strings. /// public interface IExpressionParser { /// /// Attempts to parse the input string as an expression. /// /// The input string. /// When this method returns, contains the parsed expression if the parse was successful, or null otherwise. /// When this method returns, contains the list of diagnostics produced during parsing. /// true if the parse was successful; otherwise, false . bool TryParse(string input, out IExpression? expression, out IReadOnlyList diagnostics); /// <summary> /// Parses the input string as an expression. /// </summary> /// <param name=\"input\">The input string.</param> /// <returns>The parsed expression.</returns> /// <exception cref=\"ParseException\">Thrown if the input string cannot be parsed as an expression.</exception> IExpression Parse(string input); } } ===== src/Zentient.Abstractions.Expressions/ITypedExpression{out T}.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // namespace Zentient.Abstractions.Expressions { /// /// Represents a typed expression that can be evaluated to a value of type . /// /// The type of the value that the expression evaluates to. public interface ITypedExpression : IExpression { /// /// Evaluates the expression in the specified context. /// /// The context in which to evaluate the expression, or null for no context. /// The result of the evaluation. T Evaluate(object? context = null); } } ===== src/Zentient.Abstractions.Expressions/ParseDiagnostic.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // namespace Zentient.Abstractions.Expressions { /// /// Severity for parse diagnostics. /// public enum ParseDiagnosticSeverity { Error, Warning, Information } /// <summary> /// Represents a diagnostic message produced during parsing. /// </summary> /// <param name=\"Position\">The position in the input where the diagnostic occurred.</param> /// <param name=\"Message\">The diagnostic message.</param> /// <param name=\"Severity\">The diagnostic severity (default: Error).</param> public record ParseDiagnostic(int Position, string Message, ParseDiagnosticSeverity Severity = ParseDiagnosticSeverity.Error); } ===== src/Zentient.Expressions/ConstantExpression.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using System.Globalization; using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Represents a literal constant expression. /// internal sealed class ConstantExpression : ExpressionBase { /// /// Gets the constant value represented by this node. /// public object? Value { get; } /// <summary> /// Creates a new <see cref=\"ConstantExpression\"/> with the given value. /// </summary> /// <param name=\"value\">The constant value (may be <c>null</c>).</param> public ConstantExpression(object? value) => Value = value; /// <inheritdoc /> public override ExpressionKind Kind => ExpressionKind.Constant; /// <inheritdoc /> public override IReadOnlyList<IExpression> Operands => Array.Empty<IExpression>(); /// <summary> /// Produces a canonical string representation of the value. /// Strings are quoted and escape sequences are applied; <c>null</c> renders as \"null\". /// </summary> public override string Canonical => Value switch { string s => $\"\\\"{EscapeString(s)}\\\"\", null => \"null\", _ => Convert.ToString(Value, CultureInfo.InvariantCulture) ?? \"null\" }; // Escape backslash first, then other characters private static string EscapeString(string s) { if (string.IsNullOrEmpty(s)) return s; var sb = new System.Text.StringBuilder(); foreach (var ch in s) { switch (ch) { case '\\\\': sb.Append(\"\\\\\\\\\"); break; // backslash => \\\\\\\\ in string literal case '\"': sb.Append(\"\\\\\\\"\"); break; // quote => \\\" case '\\n': sb.Append(\"\\\\n\"); break; case '\\r': sb.Append(\"\\\\r\"); break; case '\\t': sb.Append(\"\\\\t\"); break; default: sb.Append(ch); break; } } return sb.ToString(); } } } ===== src/Zentient.Expressions/ExpressionBase.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Base implementation for expression AST nodes. /// internal abstract class ExpressionBase : IExpression { /// /// Gets the kind of this expression node. /// public abstract ExpressionKind Kind { get; } /// <summary> /// Gets a canonical, language-independent representation of this expression node. /// </summary> public abstract string Canonical { get; } /// <summary> /// Gets the child operands of this expression node. Leaf nodes typically return an empty collection. /// </summary> public virtual IReadOnlyList<IExpression> Operands => Array.Empty<IExpression>(); } } ===== src/Zentient.Expressions/ExpressionDebugExtensions.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Debugging and utility extensions for expressions. /// public static class ExpressionDebugExtensions { /// /// Returns the canonical string representation of the specified expression. /// /// The expression to obtain the canonical representation for. /// A canonical, language-independent string for . public static string ToCanonicalString(this IExpression expr) => expr.Canonical; } } ===== src/Zentient.Expressions/ExpressionParser.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; using System; using System.Collections.Generic; using System.Linq; namespace Zentient.Expressions { /// /// Internal parsing helpers that produce an and diagnostics. /// internal static class ExpressionParser { /// /// Attempts to parse into an and collects diagnostics. /// /// The input expression text to parse. /// When this method returns, contains the parsed expression if parsing succeeded; otherwise null . /// When this method returns, contains a read-only list of diagnostics observed during parsing. /// true when parsing succeeded with no diagnostics; otherwise false . public static bool TryParse( string input, out IExpression? expression, out IReadOnlyList diagnostics) { var diags = new List (); if (string.IsNullOrWhiteSpace(input)) { diags.Add(new ParseDiagnostic(0, \"Expression is empty or whitespace.\")); expression = null; diagnostics = diags; return false; } var parser = new Parser(input); var expr = parser.ParseExpression(); diags.AddRange(parser.Diagnostics); diagnostics = diags; if (expr is null || diags.Count > 0) { expression = expr; return false; } ExpressionRegistry.RaiseParsed(expr); expression = expr; diagnostics = diags; return true; } /// <summary> /// Parses the specified input and returns an <see cref=\"IExpression\"/>. /// </summary> /// <param name=\"input\">The input expression text to parse.</param> /// <returns>The parsed expression.</returns> /// <exception cref=\"ArgumentException\">Thrown when parsing fails. The exception message contains concatenated diagnostic messages.</exception> public static IExpression Parse(string input) { if (!TryParse(input, out var expr, out var diags)) { var message = string.Join(\"; \", diags.Select(d => d.Message)); throw new ArgumentException($\"Failed to parse expression: {message}\"); } return expr!; } } } ===== src/Zentient.Expressions/ExpressionRegistry.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using System; using System.Collections.Generic; using System.Globalization; using System.Linq; using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Central registry that exposes default expression parser and evaluator implementations /// and lifecycle events for parsed and evaluated expressions. /// /// /// This static type is thread-safe for replacing the default parser/evaluator and for /// subscribing/unsubscribing to events. Consumers may replace the defaults or subscribe /// to and to receive notifications. /// public static class ExpressionRegistry { private static readonly object _sync = new(); private static IExpressionParser _defaultParser = new DefaultExpressionParser(); /// <summary> /// Gets or sets the default <see cref=\"IExpressionParser\"/> used by the library. /// </summary> /// <remarks> /// Setting the value is thread-safe. Attempting to assign <c>null</c> will throw /// <see cref=\"ArgumentNullException\"/>. /// </remarks> /// <exception cref=\"ArgumentNullException\">Thrown when <paramref name=\"value\"/> is <c>null</c>.</exception> public static IExpressionParser DefaultParser { get => _defaultParser; set { if (value is null) throw new ArgumentNullException(nameof(value)); lock (_sync) { _defaultParser = value; } } } private static IExpressionEvaluator _defaultEvaluator = new DefaultExpressionEvaluator(); /// <summary> /// Gets or sets the default <see cref=\"IExpressionEvaluator\"/> used by the library. /// </summary> /// <remarks> /// Setting the value is thread-safe. Attempting to assign <c>null</c> will throw /// <see cref=\"ArgumentNullException\"/>. /// </remarks> /// <exception cref=\"ArgumentNullException\">Thrown when <paramref name=\"value\"/> is <c>null</c>.</exception> public static IExpressionEvaluator DefaultEvaluator { get => _defaultEvaluator; set { if (value is null) throw new ArgumentNullException(nameof(value)); lock (_sync) { _defaultEvaluator = value; } } } private static Action<IExpression>? _onParsed; /// <summary> /// Event raised after an <see cref=\"IExpression\"/> has been successfully parsed. /// </summary> /// <remarks> /// Event handlers will be invoked with the parsed expression. Subscription and /// unsubscription are performed under a lock to ensure thread-safety. /// </remarks> public static event Action<IExpression> OnParsed { add { lock (_sync) { _onParsed += value; } } remove { lock (_sync) { _onParsed -= value; } } } private static Action<IExpression, object?>? _onEvaluated; /// <summary> /// Event raised after an <see cref=\"IExpression\"/> has been evaluated. /// </summary> /// <remarks> /// Handlers receive the expression and the evaluation result (which may be <c>null</c>). /// Subscription and unsubscription are thread-safe. /// </remarks> public static event Action<IExpression, object?> OnEvaluated { add { lock (_sync) { _onEvaluated += value; } } remove { lock (_sync) { _onEvaluated -= value; } } } /// <summary> /// Invokes the <see cref=\"OnParsed\"/> event for a parsed expression. /// </summary> /// <param name=\"expr\">The parsed expression to publish to subscribers.</param> internal static void RaiseParsed(IExpression expr) => _onParsed?.Invoke(expr); /// <summary> /// Invokes the <see cref=\"OnEvaluated\"/> event for an evaluated expression. /// </summary> /// <param name=\"expr\">The expression that was evaluated.</param> /// <param name=\"result\">The result of the evaluation; may be <c>null</c>.</param> internal static void RaiseEvaluated(IExpression expr, object? result) => _onEvaluated?.Invoke(expr, result); // Adapter implementations for the public parser/evaluator /// <summary> /// Internal adapter that delegates parsing calls to the concrete parser implementation. /// </summary> private class DefaultExpressionParser : IExpressionParser { /// <inheritdoc /> public bool TryParse(string input, out IExpression? expression, out IReadOnlyList<ParseDiagnostic> diagnostics) => ExpressionParser.TryParse(input, out expression, out diagnostics); /// <inheritdoc /> public IExpression Parse(string input) => ExpressionParser.Parse(input); } /// <summary> /// Internal adapter that delegates evaluation calls to the concrete evaluator implementation. /// </summary> private class DefaultExpressionEvaluator : IExpressionEvaluator { /// <inheritdoc /> public object? Evaluate(IExpression expression, object? context = null) { var result = StubEvaluator.Evaluate(expression, context); ExpressionRegistry.RaiseEvaluated(expression, result); return result; } } /// <summary> /// Creates a typed view over an existing expression using the registry's evaluator. /// </summary> /// <typeparam name=\"T\">The expected result type of the expression.</typeparam> /// <param name=\"expr\">The expression to wrap.</param> /// <returns>An <see cref=\"ITypedExpression{T}\"/> that evaluates the underlying expression and casts the result to <typeparamref name=\"T\"/>.</returns> public static ITypedExpression<T> AsTyped<T>(IExpression expr) { if (expr is null) throw new ArgumentNullException(nameof(expr)); return new TypedExpression<T>(expr); } // Internal wrapper implementing the typed expression contract. private sealed class TypedExpression<T> : ITypedExpression<T> { private readonly IExpression _inner; public TypedExpression(IExpression inner) => _inner = inner ?? throw new ArgumentNullException(nameof(inner)); public ExpressionKind Kind => _inner.Kind; public string Canonical => _inner.Canonical; public IReadOnlyList<IExpression> Operands => _inner.Operands; public T Evaluate(object? context = null) { var result = ExpressionRegistry.DefaultEvaluator.Evaluate(_inner, context); if (result is null && default(T) is null) return (T)result!; // allow null for reference types if (result is T t) return t; // Try convert common primitive/numeric types try { var converted = Convert.ChangeType(result, typeof(T)); return (T)converted!; } catch (Exception ex) { throw new InvalidCastException($\"Cannot cast evaluator result of type '{result?.GetType()}' to '{typeof(T)}'.\", ex); } } } } } ===== src/Zentient.Expressions/Extensions.cs ===== // // Copyright © 2025 Zentient Framework Team. All rights reserved. // using System.Collections.Generic; using Zentient.Abstractions.Expressions; namespace Zentient.Extensions.Expressions { /// /// Ergonomic extension methods for common expression workflows. /// public static class Extensions { /// /// Parses and evaluates the provided expression text using the default registry parser and evaluator. /// Returns the evaluation result or throws when parsing fails. /// public static object? EvaluateExpression(this string expressionText, object? context = null) { if (expressionText is null) throw new System.ArgumentNullException(nameof(expressionText)); var parser = Zentient.Expressions.ExpressionRegistry.DefaultParser; if (!parser.TryParse(expressionText, out var expr, out var diags)) { var msg = string.Join(';', System.Linq.Enumerable.Select(diags, d => d.Message)); throw new System.ArgumentException($\"Failed to parse expression: {msg}\"); } return Zentient.Expressions.ExpressionRegistry.DefaultEvaluator.Evaluate(expr!, context); } /// <summary> /// Returns the canonical form of an expression. /// </summary> public static string ToCanonicalString(this IExpression expr) => expr?.Canonical ?? string.Empty; /// <summary> /// Returns a brief debug string describing the expression kind, operand count, and canonical form. /// </summary> public static string ToDebugString(this IExpression expr) => $\"Kind={expr.Kind}; Operands={expr.Operands?.Count ?? 0}; Canonical={expr.Canonical}\"; } } ===== src/Zentient.Expressions/IdentifierExpression.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Represents an identifier (variable or parameter name). /// internal sealed class IdentifierExpression : ExpressionBase { /// /// Gets the identifier name. /// public string Name { get; } /// <summary> /// Initializes a new instance of <see cref=\"IdentifierExpression\"/>. /// </summary> /// <param name=\"name\">The identifier name.</param> public IdentifierExpression(string name) => Name = name; /// <inheritdoc /> public override ExpressionKind Kind => ExpressionKind.Identifier; /// <inheritdoc /> public override IReadOnlyList<IExpression> Operands => Array.Empty<IExpression>(); /// <inheritdoc /> public override string Canonical => Name; } } ===== src/Zentient.Expressions/LambdaExpression.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Represents a lambda (anonymous function) expression with parameters and a body. /// internal sealed class LambdaExpression : ExpressionBase { /// /// Gets the lambda parameter names. /// public IReadOnlyList Parameters { get; } /// <summary> /// Gets the lambda body expression. /// </summary> public IExpression Body { get; } /// <summary> /// Initializes a new instance of <see cref=\"LambdaExpression\"/>. /// </summary> /// <param name=\"parameters\">The parameter names used by the lambda.</param> /// <param name=\"body\">The body expression.</param> public LambdaExpression(IEnumerable<string> parameters, IExpression body) => (Parameters, Body) = (parameters.ToArray(), body); /// <inheritdoc /> public override ExpressionKind Kind => ExpressionKind.Lambda; /// <inheritdoc /> public override IReadOnlyList<IExpression> Operands => new[] { Body }; /// <inheritdoc /> public override string Canonical => $\"{string.Join(\", \", Parameters)} => {Body.Canonical}\"; } } ===== src/Zentient.Expressions/Lexer.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // namespace Zentient.Expressions { /// /// Simple lexer that converts an input source string into a stream of instances. /// internal sealed class Lexer { private readonly string src; private int pos; /// <summary> /// Initializes a new instance of the <see cref=\"Lexer\"/> for the specified source. /// </summary> /// <param name=\"src\">The input text to tokenize.</param> public Lexer(string src) => this.src = src; /// <summary> /// Reads and returns the next token from the input. Whitespace is skipped. /// Returns a <see cref=\"TokenType.End\"/> token when the end of input is reached. /// </summary> /// <returns>The next <see cref=\"Token\"/> read from the input stream.</returns> public Token Next() { SkipWhitespace(); if (pos >= src.Length) return new Token(TokenType.End, \"\", pos); int start = pos; char c = src[pos]; if (char.IsLetter(c) || c == '_') return ReadIdentifier(start); if (char.IsDigit(c)) return ReadNumber(start); if (c == '\"') return ReadString(start); // handle multi-character token '=>' first if (c == '=' && pos + 1 < src.Length && src[pos + 1] == '>') { pos += 2; return new Token(TokenType.Arrow, \"=>\", start); } // single-character punctuation pos++; return c switch { '.' => new Token(TokenType.Dot, \".\", start), ',' => new Token(TokenType.Comma, \",\", start), '(' => new Token(TokenType.LParen, \"(\", start), ')' => new Token(TokenType.RParen, \")\", start), _ => new Token(TokenType.End, \"\", start) }; } /// <summary> /// Reads an identifier token beginning at <paramref name=\"start\"/>. /// Identifiers may contain letters, digits and underscore. /// </summary> /// <param name=\"start\">Start index in the source where the identifier begins.</param> /// <returns>A token of type <see cref=\"TokenType.Identifier\"/>.</returns> private Token ReadIdentifier(int start) { while (pos < src.Length && (char.IsLetterOrDigit(src[pos]) || src[pos] == '_')) pos++; string text = src[start..pos]; return new Token(TokenType.Identifier, text, start); } /// <summary> /// Reads a numeric token (digits and optional decimal point). /// The lexer performs only lexical recognition; numeric validation occurs during parsing. /// </summary> /// <param name=\"start\">Start index in the source where the number begins.</param> /// <returns>A token of type <see cref=\"TokenType.Number\"/>.</returns> private Token ReadNumber(int start) { while (pos < src.Length && (char.IsDigit(src[pos]) || src[pos] == '.')) pos++; string text = src[start..pos]; return new Token(TokenType.Number, text, start); } /// <summary> /// Reads a double-quoted string literal and returns its unquoted content as the token text. /// Supports common escape sequences: \\\\, \\\" , \\n, \\r, \\t. Reports unterminated strings by returning a token with IsComplete=false. /// </summary> /// <param name=\"start\">Start index pointing at the opening quote.</param> /// <returns>A token of type <see cref=\"TokenType.String\"/> containing the unquoted string content.</returns> private Token ReadString(int start) { pos++; // skip opening \" var sb = new System.Text.StringBuilder(); bool terminated = false; while (pos < src.Length) { char ch = src[pos]; if (ch == '\"') { terminated = true; pos++; // consume closing quote break; } if (ch == '\\\\' && pos + 1 < src.Length) { // handle escape sequences char next = src[pos + 1]; switch (next) { case '\\\\': sb.Append('\\\\'); break; case '\"': sb.Append('\"'); break; case 'n': sb.Append('\\n'); break; case 'r': sb.Append('\\r'); break; case 't': sb.Append('\\t'); break; default: // unknown escape: preserve the character as-is sb.Append(next); break; } pos += 2; continue; } sb.Append(ch); pos++; } // If not terminated, capture the remainder as text and mark incomplete if (!terminated) { string textRem = src.Substring(start + 1); pos = src.Length; return new Token(TokenType.String, textRem, start, isComplete: false); } return new Token(TokenType.String, sb.ToString(), start, isComplete: true); } /// <summary> /// Peeks one character ahead of the current position, returning '\\0' when at or past the end. /// Used for recognizing multi-character tokens like \"=>\". /// </summary> /// <returns>The next character or '\\0' if none.</returns> private char Peek() => pos + 1 < src.Length ? src[pos + 1] : '\\0'; /// <summary> /// Advances the internal cursor past any contiguous whitespace characters. /// </summary> private void SkipWhitespace() { while (pos < src.Length && char.IsWhiteSpace(src[pos])) pos++; } } } ===== src/Zentient.Expressions/MemberAccessExpression.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Represents accessing a member on a target expression (for example: target.Member). /// internal sealed class MemberAccessExpression : ExpressionBase { /// /// Gets the target expression whose member is accessed. /// public IExpression Target { get; } /// <summary> /// Gets the member name being accessed. /// </summary> public string MemberName { get; } /// <summary> /// Initializes a new instance of <see cref=\"MemberAccessExpression\"/>. /// </summary> /// <param name=\"target\">The target expression.</param> /// <param name=\"memberName\">The member name.</param> public MemberAccessExpression(IExpression target, string memberName) => (Target, MemberName) = (target, memberName); /// <inheritdoc /> public override ExpressionKind Kind => ExpressionKind.MemberAccess; /// <inheritdoc /> public override IReadOnlyList<IExpression> Operands => new[] { Target }; /// <inheritdoc /> public override string Canonical => $\"{Target.Canonical}.{MemberName}\"; } } ===== src/Zentient.Expressions/MethodCallExpression.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Represents a method call expression on a target with arguments. /// internal sealed class MethodCallExpression : ExpressionBase { /// /// Gets the target expression on which the method is invoked. /// public IExpression Target { get; } /// <summary> /// Gets the method name to invoke. /// </summary> public string MethodName { get; } /// <summary> /// Gets the call arguments. /// </summary> public IReadOnlyList<IExpression> Arguments { get; } /// <summary> /// Initializes a new instance of <see cref=\"MethodCallExpression\"/>. /// </summary> /// <param name=\"target\">The target expression.</param> /// <param name=\"methodName\">The method name.</param> /// <param name=\"args\">The arguments to the method.</param> public MethodCallExpression( IExpression target, string methodName, IEnumerable<IExpression> args) { Target = target; MethodName = methodName; Arguments = args.ToArray(); } /// <inheritdoc /> public override ExpressionKind Kind => ExpressionKind.MethodCall; /// <inheritdoc /> public override IReadOnlyList<IExpression> Operands => new[] { Target }.Concat(Arguments).ToArray(); /// <inheritdoc /> public override string Canonical => $\"{Target.Canonical}.{MethodName}({string.Join(\", \", Arguments.Select(a => a.Canonical))})\"; } } ===== src/Zentient.Expressions/Parser.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using System.Globalization; using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Recursive-descent parser that converts a token stream into an AST and collects diagnostics. /// internal sealed class Parser { private readonly List tokens = new(); private int idx; private readonly List diagnostics = new(); /// <summary> /// Gets the diagnostics produced while parsing. The collection may be empty when parsing succeeds. /// </summary> public IReadOnlyList<ParseDiagnostic> Diagnostics => diagnostics; /// <summary> /// Initializes a new instance of the <see cref=\"Parser\"/> that tokenizes the provided source string. /// </summary> /// <param name=\"src\">The expression source text to parse.</param> public Parser(string src) { var lexer = new Lexer(src); Token tok; do { tok = lexer.Next(); tokens.Add(tok); } while (tok.Type != TokenType.End); } /// <summary> /// Parses an expression from the current token stream. When parsing fails, diagnostics are recorded. /// </summary> /// <returns>The parsed <see cref=\"IExpression\"/> when successful; otherwise <c>null</c>.</returns> public IExpression? ParseExpression() { if (Peek().Type == TokenType.End) { diagnostics.Add(new ParseDiagnostic(0, \"Empty expression\")); return null; } var expr = ParseLambdaOrMemberOrCall(); if (Peek().Type != TokenType.End) { var tok = Peek(); diagnostics.Add(new ParseDiagnostic(tok.Position, $\"Unexpected token '{tok.Text}'\")); } return expr; } /// <summary> /// Parses either a lambda expression, a member access chain, or a method call starting at the current token. /// Handles primary expressions (identifiers, numbers, strings) and folds trailing member/access or invocation. /// </summary> /// <returns>The parsed expression or <c>null</c> on error.</returns> private IExpression? ParseLambdaOrMemberOrCall() { if (IsIdentifierList() && PeekNext().Type == TokenType.Arrow) return ParseLambda(); IExpression? expr = Peek().Type switch { TokenType.Identifier => new IdentifierExpression(Consume().Text), TokenType.Number => TryParseNumber(), TokenType.String => TryParseString(), _ => null }; if (expr is null) { var tok = Peek(); diagnostics.Add(new ParseDiagnostic(tok.Position, $\"Unexpected token '{tok.Text}'\")); return null; } while (Peek().Type == TokenType.Dot) { Consume(); // '.' if (Peek().Type != TokenType.Identifier) { var err = Peek(); diagnostics.Add(new ParseDiagnostic(err.Position, \"Identifier expected after '.'\")); break; } var name = Consume().Text; expr = Peek().Type == TokenType.LParen ? ParseMethodCall(expr, name) : new MemberAccessExpression(expr, name); } return expr; } /// <summary> /// Determines whether the token sequence beginning at the current index represents /// a comma-separated identifier list suitable for lambda parameters (e.g. \"x, y =>\"). /// </summary> /// <returns><c>true</c> when a comma-separated identifier list is followed by an arrow token.</returns> private bool IsIdentifierList() { int i = idx; if (tokens[i].Type != TokenType.Identifier) return false; i++; while (i < tokens.Count && tokens[i].Type == TokenType.Comma) i += 2; return i < tokens.Count && tokens[i].Type == TokenType.Arrow; } /// <summary> /// Parses a lambda expression in the form \"param, ... => body\". /// Parameters are consumed from the token stream and the body is parsed. /// </summary> /// <returns>A <see cref=\"LambdaExpression\"/> representing the parsed lambda.</returns> private IExpression? ParseLambda() { var parameters = new List<string>(); do { parameters.Add(Consume().Text); } while (Peek().Type == TokenType.Comma && Consume().Type == TokenType.Comma); Consume(); // Arrow var body = ParseLambdaOrMemberOrCall() ?? new ConstantExpression(null); return new LambdaExpression(parameters, body); } /// <summary> /// Parses a method call expression given a previously parsed target and method name. /// Expects to be positioned at the opening '(' when called. /// </summary> /// <param name=\"target\">The target expression on which the method is invoked.</param> /// <param name=\"name\">The method name.</param> /// <returns>A <see cref=\"MethodCallExpression\"/> representing the invocation.</returns> private MethodCallExpression ParseMethodCall(IExpression target, string name) { Consume(); // LParen var args = new List<IExpression>(); if (Peek().Type != TokenType.RParen) { do { var arg = ParseLambdaOrMemberOrCall(); if (arg != null) args.Add(arg); } while (Peek().Type == TokenType.Comma && Consume().Type == TokenType.Comma); } Consume(); // RParen return new MethodCallExpression(target, name, args); } /// <summary> /// Attempts to parse the current numeric token into a numeric constant expression using invariant culture. /// When parsing fails a diagnostic is recorded and a <see cref=\"ConstantExpression\"/> with a null value is returned. /// </summary> /// <returns>An <see cref=\"IExpression\"/> representing the numeric constant (or null constant on error).</returns> private IExpression TryParseNumber() { var tok = Consume(); if (double.TryParse(tok.Text, NumberStyles.Any, CultureInfo.InvariantCulture, out var d)) return new ConstantExpression(d); diagnostics.Add(new ParseDiagnostic(tok.Position, $\"Invalid number '{tok.Text}'\")); return new ConstantExpression(null); } /// <summary> /// Consumes the current string token and returns a <see cref=\"ConstantExpression\"/> containing its text. /// </summary> /// <returns>An <see cref=\"IExpression\"/> representing the string constant.</returns> private IExpression TryParseString() { var tok = Consume(); if (!tok.IsComplete) { diagnostics.Add(new ParseDiagnostic(tok.Position, \"Unterminated string literal\")); return new ConstantExpression(null); } return new ConstantExpression(tok.Text); } /// <summary> /// Returns the token at the current parser index without consuming it. /// </summary> /// <returns>The current <see cref=\"Token\"/>.</returns> private Token Peek() => tokens[idx]; /// <summary> /// Returns the token immediately after the current parser index without consuming it. /// If the lookahead is out of range the current token is returned. /// </summary> /// <returns>The next <see cref=\"Token\"/> or the current token if lookahead is not available.</returns> private Token PeekNext() => idx + 1 < tokens.Count ? tokens[idx + 1] : Peek(); /// <summary> /// Consumes and returns the token at the current index, advancing the parser position by one. /// </summary> /// <returns>The consumed <see cref=\"Token\"/>.</returns> private Token Consume() => tokens[idx++]; } } ===== src/Zentient.Expressions/StubEvaluator.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// Minimal evaluator used internally by tests/stubs. Supports constant expressions and /// simple identifier/member lookup from IDictionary<string, object?> contexts. /// internal static class StubEvaluator { /// /// Evaluates the specified expression and returns a result. /// /// The expression to evaluate. /// An optional evaluation context. If a IDictionary<string, object?> is provided identifiers and member access will be resolved from it. /// The evaluated value for supported node types; otherwise null . public static object? Evaluate(IExpression expr, object? context) { return expr switch { ConstantExpression c => c.Value, IdentifierExpression id => ResolveIdentifier(id.Name, context), MemberAccessExpression m => ResolveMember(m.Target, m.MemberName, context), MethodCallExpression mc => EvaluateMethodCall(mc, context), _ => null }; } private static object? ResolveIdentifier(string name, object? context) { if (context is System.Collections.IDictionary dict) { if (dict.Contains(name)) return dict[name]; } else if (context is System.Collections.Generic.IDictionary<string, object?> gen) { if (gen.TryGetValue(name, out var v)) return v; } return null; } private static object? ResolveMember(IExpression targetExpr, string memberName, object? context) { var targetVal = Evaluate(targetExpr, context); if (targetVal is System.Collections.IDictionary dict) { if (dict.Contains(memberName)) return dict[memberName]; } else if (targetVal is System.Collections.Generic.IDictionary<string, object?> gen) { if (gen.TryGetValue(memberName, out var v)) return v; } // As a fallback, reflect public properties if (targetVal is not null) { var t = targetVal.GetType(); var prop = t.GetProperty(memberName); if (prop != null) return prop.GetValue(targetVal); } return null; } private static object? EvaluateMethodCall(MethodCallExpression mc, object? context) { var target = Evaluate(mc.Target, context); var rawArgs = mc.Arguments.Select(a => Evaluate(a, context)).ToArray(); // If target is a delegate, invoke with coerced args if (target is Delegate d) { var adapted = AdaptArgumentsForDelegate(d, rawArgs); return adapted is null ? null : InvokeDelegate(d, adapted); } // If target is a dictionary containing the method name as a delegate, invoke it if (target is System.Collections.Generic.IDictionary<string, object?> targetGen && targetGen.TryGetValue(mc.MethodName, out var maybeDel) && maybeDel is Delegate del2) { var adapted = AdaptArgumentsForDelegate(del2, rawArgs); return adapted is null ? null : InvokeDelegate(del2, adapted); } if (target is System.Collections.IDictionary targetDict && targetDict.Contains(mc.MethodName) && targetDict[mc.MethodName] is Delegate del3) { var adapted = AdaptArgumentsForDelegate(del3, rawArgs); return adapted is null ? null : InvokeDelegate(del3, adapted); } // Try lookup in context by method name when target didn't provide it if (context is System.Collections.Generic.IDictionary<string, object?> dict && dict.TryGetValue(mc.MethodName, out var maybeDel2) && maybeDel2 is Delegate dd) { var adapted = AdaptArgumentsForDelegate(dd, rawArgs); return adapted is null ? null : InvokeDelegate(dd, adapted); } if (context is System.Collections.IDictionary ctxDict && ctxDict.Contains(mc.MethodName) && ctxDict[mc.MethodName] is Delegate dd2) { var adapted = AdaptArgumentsForDelegate(dd2, rawArgs); return adapted is null ? null : InvokeDelegate(dd2, adapted); } // As a final fallback, try reflection on the target for a delegate-valued property if (target is not null) { var t = target.GetType(); var prop = t.GetProperty(mc.MethodName); if (prop != null) { var val = prop.GetValue(target); if (val is Delegate ddd) { var adapted = AdaptArgumentsForDelegate(ddd, rawArgs); return adapted is null ? null : InvokeDelegate(ddd, adapted); } } } // Deep search: find delegate by key in nested dictionaries or properties var found = FindDelegateInObject(target, mc.MethodName) ?? FindDelegateInObject(context, mc.MethodName); if (found is Delegate fdel) { var adapted = AdaptArgumentsForDelegate(fdel, rawArgs); return adapted is null ? null : InvokeDelegate(fdel, adapted); } return null; } private static object? InvokeDelegate(Delegate del, object[] args) { // Allow exceptions to surface so calling tests can detect invocation issues return del.DynamicInvoke(args); } private static object[]? AdaptArgumentsForDelegate(Delegate del, object?[] rawArgs) { var parameters = del.Method.GetParameters(); if (parameters.Length != rawArgs.Length) return null; var adapted = new object?[rawArgs.Length]; for (int i = 0; i < rawArgs.Length; i++) { var targetType = parameters[i].ParameterType; var val = rawArgs[i]; if (val == null) { adapted[i] = null; continue; } if (targetType.IsInstanceOfType(val)) { adapted[i] = val; continue; } try { adapted[i] = Convert.ChangeType(val, targetType); } catch { // Failed to convert return null; } } return adapted.Cast<object>().ToArray(); } private static object? FindDelegateInObject(object? obj, string methodName) { if (obj is null) return null; if (obj is Delegate d) return d; if (obj is System.Collections.Generic.IDictionary<string, object?> gen) { if (gen.TryGetValue(methodName, out var v) && v is Delegate dv) return dv; foreach (var val in gen.Values) { var found = FindDelegateInObject(val, methodName); if (found is Delegate) return found; } } if (obj is System.Collections.IDictionary nonGen) { if (nonGen.Contains(methodName) && nonGen[methodName] is Delegate dv2) return dv2; foreach (System.Collections.DictionaryEntry entry in nonGen) { var found = FindDelegateInObject(entry.Value, methodName); if (found is Delegate) return found; } } // reflect properties var t = obj.GetType(); foreach (var prop in t.GetProperties()) { var val = prop.GetValue(obj); var found = FindDelegateInObject(val, methodName); if (found is Delegate) return found; } return null; } } } ===== src/Zentient.Expressions/StubTypedExpression.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // using Zentient.Abstractions.Expressions; namespace Zentient.Expressions { /// /// A lightweight wrapper implementing around an existing . /// The evaluation uses the internal and not a full evaluator. /// /// The target CLR type for evaluation. internal sealed class StubTypedExpression : ITypedExpression { private readonly IExpression _inner; /// <summary> /// Initializes a new instance that wraps <paramref name=\"inner\"/>. /// </summary> /// <param name=\"inner\">The inner expression to evaluate.</param> public StubTypedExpression(IExpression inner) => _inner = inner; /// <inheritdoc /> public ExpressionKind Kind => _inner.Kind; /// <inheritdoc /> public string Canonical => _inner.Canonical; /// <inheritdoc /> public IReadOnlyList<IExpression> Operands => _inner.Operands; /// <summary> /// Evaluates the wrapped expression using the internal stub evaluator and returns a value of type <typeparamref name=\"T\"/>. /// </summary> /// <param name=\"context\">An optional context object passed to the evaluator.</param> /// <returns>The evaluated value converted to <typeparamref name=\"T\"/> when possible; otherwise the default of <typeparamref name=\"T\"/>.</returns> public T Evaluate(object? context = null) { var result = StubEvaluator.Evaluate(_inner, context); ExpressionRegistry.RaiseEvaluated(_inner, result); return result is T t ? t : default!; } } } ===== src/Zentient.Expressions/Token.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // namespace Zentient.Expressions { /// /// A single lexical token with its type, textual content and start position. /// internal readonly struct Token { /// Gets the token kind. public TokenType Type { get; } /// <summary> /// Gets the exact text for the token as it appeared in the source. /// For string tokens this value is the unquoted content. /// </summary> public string Text { get; } /// <summary> /// Gets the zero-based character index in the source where the token begins. /// </summary> public int Position { get; } /// <summary> /// For string tokens, indicates whether the closing quote was found. /// For other tokens this is always true. /// </summary> public bool IsComplete { get; } /// <summary> /// Initializes a new instance of <see cref=\"Token\"/>. /// </summary> /// <param name=\"type\">The token kind.</param> /// <param name=\"text\">The token text.</param> /// <param name=\"position\">Zero-based start position within the source.</param> /// <param name=\"isComplete\">For string tokens, whether the closing quote was found. Defaults to true.</param> public Token(TokenType type, string text, int position, bool isComplete = true) => (Type, Text, Position, IsComplete) = (type, text, position, isComplete); } } ===== src/Zentient.Expressions/TokenType.cs ===== // // Copyright Â© 2025 Zentient Framework Team. All rights reserved. // namespace Zentient.Expressions { /// /// Represents the kinds of lexical tokens produced by the expression lexer. /// internal enum TokenType { Identifier, Number, String, Dot, Comma, LParen, RParen, Arrow, End } }"
  },
  "docs/internal/_includes/aside.html": {
    "href": "docs/internal/_includes/aside.html",
    "title": "| Zentient.Abstractions API Reference",
    "keywords": "Documentation Landing API Reference (alfa) Release notes � alfa Roadmap Contributing Repository Code (src/) Tests (tests/)"
  },
  "docs/internal/acceptance-criteria.html": {
    "href": "docs/internal/acceptance-criteria.html",
    "title": "Acceptance Criteria for alpha release | Zentient.Abstractions API Reference",
    "keywords": "Acceptance Criteria for alpha release This checklist is intended for maintainers and release engineers to verify the minimal functional and testing requirements for the 0.1.x (alpha) release of Zentient.Testing. Follow each item and mark as Done when the project satisfies the requirement in the repository. Functional acceptance (behavior) [x] ITestScenario flows compile and can be exercised programmatically: Arrange(Action ) -> ActAsync(TInput) -> Assert(Action<IResultAssertions >). [x] Test harness resolves registered dependencies (WithDependency) and returns the registered instance. [x] Test harness constructs SUT via public constructors when all constructor parameter types are registered in harness. [x] When SUT cannot be resolved, harness throws a descriptive exception with actionable guidance. [x] Mocking DSL works for basic scenarios: IMockBuilder .Given(...).ThenReturns(...) returns configured values. IMockBuilder .Given(...).ThenThrows(...) throws the configured exception. Build(out IMockVerifier ) provides a verifier that can assert calls and call counts. [x] Assertions helpers (IResultAssertions ) support NotBeNull, HaveValue, With(selector, expected) and chaining (And). [x] Expression utilities (Zentient.Expressions) provide parsing/evaluation entry points via ExpressionRegistry.DefaultParser and DefaultEvaluator and basic evaluator supports constants, identifiers, member access and method invocation against IDictionary contexts. [x] Packaging metadata exists (PackageId, Version, IsPackable, GenerateDocumentationFile) for both Zentient.Testing and Zentient.Abstractions.Testing projects. Test acceptance (coverage & stability) [x] Unit tests cover core harness behaviors (registration, replacement, resolve, disposal). [x] Unit tests cover mock engine (Given/ThenReturns/ThenThrows + verifier semantics). [x] Unit tests cover ResultAssertions behavior and chaining. [x] Unit tests for expressions cover parser and stub evaluator basics (constants, identifiers, member access, method invocation) using public API only. [x] Integration tests exercise a representative Arrange→Act→Assert scenario resolving a handler from the harness and asserting a result. [x] Tests run reliably on CI for both target frameworks net8.0 and net9.0. (local runs verified across net8/net9) [x] No public API methods are missing XML docs (GenerateDocumentationFile builds successfully without CS1591 warnings/errors). CI / Packaging / Release readiness [x] CI builds the project and runs unit tests for all target frameworks. (workflow configured; local matrix runs successful) [x] CI packs NuGet packages with net8.0 and net9.0 outputs and verifies their contents (local verification for Zentient.Testing package completed). [x] Signing/publish pipeline placeholders exist and document required secrets (NUGET_API_KEY, SIGNING_KEY, SIGNING_PASSWORD). Checklist validation: The rest of this file is used by maintainers to record verification results locally. Verification log: Date: 2025-09-18 Executor: GitHub Copilot Notes: Ran full unit + integration tests locally across net8.0 and net9.0; all tests passed. Packed src/Zentient.Testing into artifacts/ (0.1.0-alpha.1) and inspected package generation. Local pack for Zentient.Testing succeeded and package contains expected outputs for the target frameworks. Attempted to pack the separate expressions project but its build failed in this workspace due to missing local references; leaving that project to be packaged in its own repository or after fixing its project references. Running tests via dotnet test still requires a test-framework adapter (xUnit/NUnit/MSTest). Implementing a VSTest discovery adapter for Zentient.Testing is out of scope for this alpha; recommended approach: consumers use Zentient.Testing's assertion/ harness APIs together with an existing test runner (xUnit/NUnit) until an adapter is provided."
  },
  "docs/internal/api-reference-alfa.html": {
    "href": "docs/internal/api-reference-alfa.html",
    "title": "Zentient.Testing � API Reference (alfa) | Zentient.Abstractions API Reference",
    "keywords": "Zentient.Testing � API Reference (alfa) Version: v0.1.0-alfa Scope: public surface shipped with the alfa pre-release. This reference documents the primary types, interfaces and typical usage patterns. It is intended as a developer-facing wiki page (authoritative shipped surface: PublicAPI.Shipped.txt). Table of contents Overview Key concepts Public namespaces Detailed API reference TestHarnessBuilder TestHarness TestScenario<TInput,TResult> MockEngine, IMockBuilder , IMockVerifier ResultAssertions Examples Compatibility & notes Overview Zentient.Testing is a compact testing library focused on scenario-driven handler tests and a small mock/verification engine. It aims to be lightweight and explicitly targeted at .NET 8/9. Key concepts Test harness: an execution container that wires DI, configuration and fake implementations for reproducible scenarios. Scenario: a single, focused test run described by input and expected result (sync or async). Mock engine: lightweight dynamic proxy factory that supports setup/verify patterns. Result assertions: fluent helpers to verify success / failure shapes and extract diagnostics. Public namespaces Zentient.Testing � core harnesses, scenarios, mocks and assertions. Zentient.Abstractions.Testing � minimal interfaces for DI-friendly mocking and harness composition. Zentient.Testing.Internal � internal helpers (not for public consumption; subject to change). Detailed API reference class: TestHarnessBuilder Namespace: Zentient.Testing Purpose Build and configure a TestHarness instance. The builder provides methods to register services, configure timeouts and enable specific test behaviors. Constructors TestHarnessBuilder() Fluent methods WithService (TService instance) : TestHarnessBuilder Registers a singleton instance overriding the production registration. WithTransient<TService, TImplementation>() : TestHarnessBuilder Registers a transient mapping for the harness service collection. WithConfiguration(Action configure) : TestHarnessBuilder Allows arbitrary DI configuration for advanced scenarios. WithDefaultTimeout(TimeSpan timeout) : TestHarnessBuilder Sets a harness-level timeout used by scenario execution. Terminal Build() : TestHarness Returns an immutable TestHarness configured with the specified services. Remarks The builder is safe to use in parallel for independent harnesses. class: TestHarness Namespace: Zentient.Testing Purpose Runtime container for executing scenarios and resolving services inside a controlled scope. Methods Resolve () : T Resolve a service from the harness service provider (scoped to each scenario where appropriate). CreateScenario<TInput,TResult>(TInput input) : TestScenario<TInput,TResult> Create a scenario object ready to execute with the harness' configuration. RunScenarioAsync<TInput,TResult>(TestScenario<TInput,TResult> scenario) : Task Execute a scenario using harness policies (timeouts, retries if configured). Disposal Implements IDisposable / IAsyncDisposable where underlying DI scopes or resources must be released. class: TestScenario<TInput,TResult> Namespace: Zentient.Testing Purpose Represents one test invocation including input, optional preconditions, and execution logic. Properties Input : TInput Metadata : IDictionary<string,string> (optional) Methods Execute() : TResult ExecuteAsync() : Task Usage Construct via TestHarness.CreateScenario(...). Scenarios capture context and can expose hooks for assertions or result transformations. class: MockEngine Namespace: Zentient.Testing Purpose Provides creation of mock instances and verification helpers. It is intentionally small and designed for common mocking tasks without the complexity of a full mocking framework. Methods CreateMock () : IMockBuilder Verify (T instance) : IMockVerifier interface: IMockBuilder Namespace: Zentient.Abstractions.Testing Purpose Fluent builder used to configure behaviors on a mock before materialization. Methods Setup(Expression<Action > expression) : IMockBuilder Configure a void method expectation or behavior. Setup (Expression<Func<T, TResult>> expression, TResult returnValue) : IMockBuilder Configure a function to return a value when invoked with matching arguments. Build() : T Produce the mock instance usable by consumers. interface: IMockVerifier Namespace: Zentient.Abstractions.Testing Purpose Verification API to assert that configured mocks were exercised as expected. Methods Verify(Expression<Action > expression, Times times) Ensure the expression was invoked the expected number of times. Times is a small struct with helpers: Once(), Times(int), Never(). class: ResultAssertions Namespace: Zentient.Testing Purpose Fluent result assertions to interpret success/failure shapes from scenario execution. Methods ShouldBeSuccess(this TResult) : TResult Throws an assertion exception if the result indicates failure; returns the result for chaining. ShouldBeFailure(this TResult) : TResult Asserts the result represents a failure and returns failure details for inspection. Examples Synchronous scenario example var harness = new TestHarnessBuilder() .WithService<IMyDependency>(new MyStub()) .Build(); var scenario = harness.CreateScenario<MyInput, MyResult>(new MyInput { Value = 42 }); var result = scenario.Execute(); result.ShouldBeSuccess(); Mocking example var engine = new MockEngine(); var builder = engine.CreateMock<IMyService>(); builder.Setup(s => s.Do(It.IsAny<string>()), 42); var mock = builder.Build(); // Exercise mock var v = mock.Do(\"abc\"); // returns 42 var verifier = engine.Verify<IMyService>(mock); verifier.Verify(s => s.Do(\"abc\"), Times.Once()); Compatibility & notes The alfa release aims for .NET 8/9 compatibility. Some APIs may change in the beta release. Public API is documented here for convenience; the authoritative shipped API is the PublicAPI.Shipped.txt file used by the project. If you need more detail for a particular type or module, request it and a dedicated section will be added."
  },
  "docs/internal/contributing.html": {
    "href": "docs/internal/contributing.html",
    "title": "| Zentient.Abstractions API Reference",
    "keywords": "Contributing to Zentient.Testing Welcome! We appreciate contributions. This document outlines the development workflow and expectations. Commit conventions Use Conventional Commits: type(scope): subject Types: feat, fix, docs, style, refactor, perf, test, chore, ci Branching main � default branch for releases develop � ongoing work and integration feature/, fix/ � topic branches PR process Open PRs against develop Include tests and update docs for user-visible changes CI must pass (build + tests) before merging Running tests locally dotnet build dotnet test Code style Use consistent formatting (dotnet format) Document public APIs with XML comments Issues & templates Use issue templates for bug reports and feature requests Maintainers Mention maintainers in issue comments or ping on PRs for review."
  },
  "docs/internal/index.html": {
    "href": "docs/internal/index.html",
    "title": "Zentient.Testing � Internal Documentation Landing | Zentient.Abstractions API Reference",
    "keywords": "Zentient.Testing � Internal Documentation Landing Welcome to the internal documentation for the alfa release of Zentient.Testing. This landing page provides quick links to internal reference material, release notes and contributor guidance intended for maintainers and early adopters. Note: files in docs/internal are intended for maintainers and may contain design notes or unstable API details. Do not publish these pages to public sites without reviewing sensitive content. Quick links API Reference (alfa) � full surface-area snapshot for v0.1.0-alfa Roadmap � short- and medium-term roadmap and milestones Release notes � alfa � what's included and migration guidance Contributing � contributor workflow, commit conventions and branch guidance Aside / Navigation - **Documentation** - [Landing](index.md) - [API Reference (alfa)](api-reference-alfa.md) - [Release notes � alfa](release-notes-alfa.md) - [Roadmap](roadmap.md) - [Contributing](contributing.md) Repository Code (src/) Tests (tests/) Getting started (for maintainers) Read the API reference to understand exported interfaces and expectations for consumers. Review the release notes for known issues, migration advice, and packaging notes. Follow the contributing guide for branch naming, commit messages and CI expectations. **Maintainers:** please keep this directory up to date. For questions or to propose changes to the internal docs, open an issue with the `docs/internal` label. License: content in this repository follows the repository license (see LICENSE at the root). Zentient.Testing � Internal Documentation This directory contains the internal wiki pages and documentation intended for maintainers, contributors and early adopters of the alfa release of Zentient.Testing. Files api-reference-alfa.md � full API reference for the alfa release (surface area & examples) roadmap.md � short- and medium-term roadmap and release plan release-notes-alfa.md � alfa release notes and migration guidance contributing.md � contributor guidance, development workflow and commit conventions Internal wiki (maintainer-facing) index.md � Overview & introduction wiki/getting-started.md � Quick start and running tests locally wiki/concepts.md � Core concepts and mental model wiki/architecture.md � High level architecture and extension points wiki/usage-examples.md � Recipes and example patterns How to use These pages are written for Markdown-driven hosting (GitHub Pages / Docs). Keep them up to date when you change public APIs. API reference is intentionally compact for the alfa; expand signatures and examples as APIs stabilize. Contact For questions about the design or release process open an issue or ping the maintainers in the repository. Notes These files are internal and should not be published publicly without review. They remain local to maintainers and are intentionally kept out of public releases."
  },
  "docs/internal/release-notes-alfa.html": {
    "href": "docs/internal/release-notes-alfa.html",
    "title": "| Zentient.Abstractions API Reference",
    "keywords": "Zentient.Testing � Alfa Release (v0.1.0-alfa) Overview This is the initial alfa release of Zentient.Testing. It provides a testing harness, lightweight mock engine and a set of assertions to support testing of handler-style code and expression evaluation. Highlights TestHarnessBuilder and TestHarness for orchestrating scenarios MockEngine for dynamic mock/proxy generation ResultAssertions for clearer failure messages CI/CD pipeline for packaging and GitHub Releases Breaking changes / migration API is unstable and expected to change; expect breaking changes between alfa -> beta. If you depend on public interfaces, add integration tests and pin the package version. Known issues Documentation generation is limited in this release. See DocFX workflow. Some advanced mocking scenarios may not be supported yet. See API Reference for current capabilities. Installation Install the package from the pre-release NuGet feed or from the GitHub release assets. Contact File issues on the repository for bugs or feature requests. For detailed API surface and examples see the internal API Reference or the public api.md."
  },
  "docs/internal/roadmap.html": {
    "href": "docs/internal/roadmap.html",
    "title": "| Zentient.Abstractions API Reference",
    "keywords": "Zentient.Testing Roadmap This document outlines the short-, medium-, and long-term roadmap for Zentient.Testing. Alfa (v0.1.0-alfa) � Current Stabilize core testing harness and mock engine for .NET 8/9. Provide API reference, docs and internal guidance. See API Reference and internal wiki. Basic NuGet packaging and GitHub Release flow. Integration tests for core components. Beta (v0.2.0-beta) Harden public APIs and freeze PublicAPI.Shipped.txt Add more realistic examples and samples repository Add performance benchmarks and profiling guidance Add improved doc generation (DocFX site with cross-references) Add CI checks: API compatibility, documentation link validation Release Candidate (v0.9.0-rc) Complete tests and performance tuning Add migration guides and changelog automation Introduce semantic versioning policy and stable release plan Long term (v1.0.0) Stable public API and 1.0 release Expanded integration samples and community contributions Consider split packages for core/wide feature sets Milestones & Timing Alfa: immediate Beta: within 2�3 months after feedback RC: after thorough testing and API stabilization How to contribute Open issues labeled \"roadmap\" to propose changes Provide PRs with tests and docs Join design discussions via issues or PR comments Contact Maintainers and release managers: open an issue for coordination."
  },
  "docs/overview.html": {
    "href": "docs/overview.html",
    "title": "Overview � Zentient.Testing | Zentient.Abstractions API Reference",
    "keywords": "Overview � Zentient.Testing Mission Zentient.Testing is a compact testing harness and scenario DSL that enables developers to write clear Arrange ? Act ? Assert tests for handler-style code. The project emphasizes developer ergonomics, small public APIs, and straightforward local validation. Audience Library authors and application developers who write small to medium-sized handler-style units (message handlers, command handlers, small services). Teams that prefer minimal friction and readable test code over heavyweight testing frameworks. What the alpha provides A small set of public abstractions for composing test scenarios. A lightweight mock engine for common stubbing scenarios. Assertion helpers that make test checks concise and readable. Local scripts to validate build/test/pack locally. Roadmap summary Alpha (0.1.x): Core DSL, TestHarness, simple mock engine, and documentation. Beta (0.2.x): Adapters for Microsoft DI and Moq, diagnostics, and richer verification. Release Candidate / 1.0: Roslyn analyzers, snapshot/diff features, final API stabilization and polished docs. Getting help Open an issue or discussion on the repository for questions, feature requests, or bug reports. Use the Code of Conduct when interacting with maintainers and contributors."
  },
  "docs/usage-examples.html": {
    "href": "docs/usage-examples.html",
    "title": "Usage Examples � Zentient.Testing (Alpha) | Zentient.Abstractions API Reference",
    "keywords": "Usage Examples � Zentient.Testing (Alpha) This page collects short, copy?pasteable examples that demonstrate common usage patterns for the alpha release of Zentient.Testing. These examples are minimal by design and intended to illustrate the Arrange ? Act ? Assert flow. Handler with dependency and mock The following example shows a simple handler that depends on an ICalculator service. The test registers a mock for the calculator and asserts the result. public class AdderHandler { private readonly ICalculator _calc; public AdderHandler(ICalculator calc) => _calc = calc; public int Handle((int a, int b) input) => _calc.Add(input.a, input.b); } // Arrange: create a scenario that resolves AdderHandler from the harness var scenario = TestScenario.ForHandler<AdderHandler,(int a,int b),int>((h, input, ct) => Task.FromResult(h.Handle(input))); scenario.Arrange(builder => { // Register a mock implementation that always returns 100 builder.WithMock<ICalculator>(mb => mb.Given(x => x.Add(It.IsAny<int>(), It.IsAny<int>())).ThenReturns(100)); }); // Act var result = await scenario.ActAsync((1, 2)); // Assert Assert.Equal(100, result); Assertions examples Use the ResultAssertions API to make focused assertions about the result. The API supports chaining for readable assertions. // Ensure result is not null scenario.Assert(a => a.NotBeNull()); // Assert on a selected property and expected value scenario.Assert(a => a.With(r => r.Value, 42)); Notes These examples show the alpha surface. Adapter-backed mocking (Moq) and DI hosting are planned for the beta release and will provide richer integration points. Prefer the public abstractions (ITestScenario, ITestHarnessBuilder, IMockBuilder, IResultAssertions) when writing tests so future adapter work remains compatible."
  }
}